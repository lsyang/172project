###########################################################################
# General C compiler parameters
###########################################################################

# We shall use gcc to compile C code
CC = gcc
# Use C99; print all warnings, and treat all warnings as errors
CFLAGS = -std=c99 -Wall -Werror -I../include/

ifeq ($(DEBUG),1)
# Debug symbols and asserts
CFLAGS += -g -O1
else
# Disable asserts
CFLAGS += -DNDEBUG -O3
endif

ifeq ($(CLOUD),1)
RUNTESTFLAGS += --cloud
else
CFLAGS += -march=corei7-avx -mtune=corei7-avx
endif

# Realtime and math library flags
LDFLAGS = -lrt -lm

# Command to invoke clint
CLINT = python clint.py


###########################################################################
# List of targets and C source files
###########################################################################

# Our target application
TARGETS = count_primes

# List of C source files needed to compile our target.
CSOURCES = main.c count_primes.c trialdiv.c

# Translate our list of C source files into a list of object files.
# These object files will be linked together to ultimately compile our
# target.
OBJECTS = $(CSOURCES:.c=.o)


###########################################################################
# Make rules
###########################################################################

# These make rules are PHONY, meaning that they are not expected to
# generate a file whose name matches the rule target (e.g., "$ make
# clean" does not generate a file named "clean").
.PHONY : all clean

all : $(TARGETS)


# Each C source file will have a corresponding file of prerequisites.
# Include the prerequisites for each of our C source files.
-include $(CSOURCES:.c=.d)

# This rule generates a file of prerequisites (i.e., a makefile)
# called name.d from a C source file called name.c.
%.d : %.c
	@set -e; rm -f $@; \
	$(CC) -MM $(CFLAGS) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$

# Default rule for compiling an object file from a C source file.
%.o : %.c
	$(CC) $(CFLAGS) -c $< $(LDFLAGS)

# Compile count_primes executable, and check that the resulting
# executable meets size requirement.
count_primes : $(OBJECTS)
	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)
	@if [ `stat --printf="%s" ./count_primes` -gt 1048576 ]; then \
		echo "WARNING: Executable size exceeds 1MB limit."; \
	fi

# Clean the directory of generated files 
clean :
	rm -rf *.o *.d* $(TARGETS) *~

###########################################################################
# Make rules for running tests
###########################################################################

TESTSDIR = tests
RUNTEST = ./run_tests.py

.PHONY : tests clean_tests test_prepush

# Make the results file for a specified test file
$(TESTSDIR)/%.results : $(TESTSDIR)/%.csv $(TARGETS)
	$(RUNTEST) $(RUNTESTFLAGS) $<

# Run all tests
tests : $(TARGETS)
	$(RUNTEST) $(RUNTESTFLAGS) $(TESTSDIR)/*.csv

# Clean the test directory of generated files
clean_tests :
	rm -rf $(TESTSDIR)/*.results $(TESTSDIR)/*~

# Basic tests to be run before pushing to the repository
test_prepush : clean $(TARGETS)
	@if [ `stat --printf="%s" ./count_primes` -gt 1048576 ]; then \
		echo "ERROR: Executable size exceeds 1MB limit."; exit 2; \
	fi
	$(CLINT) *.c *.h 
# You can add your own tests here, if you want them to run whenever
# you git push.
#       $(RUNTEST) $(TESTSDIR)/basictests.csv



###########################################################################
# Make rules for running tests
###########################################################################

.PHONY : perf report clean_perf

DEBUGDIR = ./.debug
PERF_RECORD = lexec perf record -o perf.data
PERF_REPORT = perf report -i perf.data --symfs=$(DEBUGDIR)
ARGS ?= 0 10

# Run perf record.  Use ARGS="<start> <length>" to override default
# arguments
record : $(TARGETS)
	$(PERF_RECORD) ./count_primes $(ARGS)

# Run perf report.
report : $(TARGETS)
	$(PERF_REPORT)

# Clean files generated by perf
clean_perf :
	rm -rf perf.data $(DEBUGDIR)
